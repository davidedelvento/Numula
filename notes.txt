11/25/21

At this point I have these tools:

1) Music21: Python library;
    defines a rich data structure for representing scores.
    These scores can be generated algorithmically,
    possibly using a compact textual notation,
    or parsed from files (musicXML or MIDI).
    They can be manipulated (volume/timing/articulation).
    They can be aggregated (e.g. chordify).
    They can be output in various forms (graphic score, test, MIDI)

2) MIDIUtils: Python library for generating MIDI files

3) PianoTeq: play MIDI files with piano sounds, to speakers or .WAV files

--------------
Some general goals:

1) "Prepared performance" with nuance,
of an existing piece (e.g. Berio or Bach).
I think it's best to use Music21 for this.
Many pieces are available on the web in various formats that Music21 can parse.
The textual notation makes it easy to enter new pieces.

What I need to write are functions that apply nuance to Stream objects.

Need to find out if Music21 distinguishes between notated time and performed time.

2) Algorithmic composition
Simple examples can be done directly using MIDIUtils,
but going forward I think it's better to use Music21.
- Can produce graphic scores
- Can use nuance operators as above
- Can use other Music21 features (pitch sets etc.)

3) Nuance analysis
If we have a score for a piece (say, MusicXML)
and the MIDI file for a human performance of the piece,
we could write a program to correlate the two and extract the nuance
(e.g. timing variation, horizontal/vertical dynamics, etc.)
This would be useful for defining nuance primitives, and it would make a good paper.

=====================

text notation

1/4 c4 d e f+ . a- +f+ 1/8 g {c e g}

1/4 or /4: duration of following notes

.: rest

c4: middle C

d: the D closest to previous pitch

f+: F sharp

+f: first F above previous pitch
++f: 2nd F above previous pitch

{c e g}: chord

{c e 1/2 g}: chord, g is half note

1/8 _: back up an eighth

NoteSet
    maintains current time, last vol, last dur
    NoteSet ns
    ns.append(n('a b c'))
    ns.insert(time, n('a b c'))
    ns.set_vol(), set_time(), set_dur()
    ns.get_time()

Nuance:
    have notion of "current time"
    time(x): set time
    dt(x): advane time

timing primitives:
Notes have
    "score time" - static
        use a slop factor for "simultaneous" because of roundoff
        score duration
    "performed time": seconds
        performed duration
    stages:
        1) tempo
            defines a continuous function from score to performed time
            seg(dt, func, params)
            func is a function that computes the integral of a tempo function
            e.g. linear(dt, tempo0, tempo1)(a,b)
                returns the integral of a line between a and b,
                where 0 <= a < b <= dt
            could also have exponential, etc.
            e.g.:
                ns.start()
                tseg(ns, 8/4, linear, [40, 60])
                tseg(ns, 8/4, linear, [60, 50])
            segment boundaries may not line up with note times,
            so some tricky computation is needed
            one approach:
                given the NoteSet, make another data structure which
                    has start and end records, each with a pointer to a Note.
                    Traverse this, computing performed times.
                    For start records, fill in Note.perf_time
                    For end records, fill in Note.perf_duration
            
        2) adjustments
            these change the time of some notes;
                thay may also add a delay to everything later
                times are in seconds
            pause(t, dt, before)
                pause goes before notes at t
                    increment start time of notes at t and after
                    increment duration of notes before t but active at t
                        (need to scan from start to find these)
                pause goes after notes at t
                    lengthen duration of notes starting at t
                    increments start times of notes after t
            roll_up(t, offsets, delay)
                offsets: list of (usually negative) time offsets, low to high
                dt = range of offsets used
                if delay:
                    add dt to all notes t and beyond
                    add offsets to notes at t
                else:
                    add offsets to notes at t
            roll_down: same, but offsets are high to low
                agogic accent is a special case (delay top note)
            adjust_list(offsets, pred)
                apply list of offsets to note satisfying pred
                e.g. rubato
            adjust_notes(offset, pred)
                add offset to notes satisfying pred
            random_uniform(min, max, pred)
                apply random uniform shift
            random_normal(stddev, max_sigma)

dynamics primitives
    volume is represented as 1..127
    adjustments to volume are represented as fractions (0..1), possibly > 1
    adjusted volumes are pegged at 1 and 127
        (print when this happens)

    stages:
        1) set base volume (e.g. crescendos)
            dyn(dt, v0, v1)
        2) adjust volume
            vol_adjust(ns, atten, pred)
                can use this to voice to top/bottom
            vol_adjust_func(ns, func, pred)
                can use this for metric emphases

            v_random_uniform(ns, min, max, pred)
            v_random_normal(ns, stddev, max_sigma, pred)
                apply random change

notes on outer:
    need to sort of simulate the piece to figure out it a note is highest and/or lowest
    cur_time = 0
    S = notes active at current time
    C = notes started at current time
    C is always a subset of S
    for each note N
        if n.time > cur_time+1e-4:
            is len(C):
                find min, max of pitches in S
                for each note in C
                    if pitch = min, tag as lowest
                    if pitch = max, tag as highest
            cur_time = N.time
            remove notes from S that end <= cur_time
            C = {N}
        else:
            add N to S
            add N to C

Note selection (for timing/vol adjustment, articulation)
    Notes have the following attributes:
        pitch, dur, time, vol
        tags explicitly assigned
        highest/lowest
        number of simultaneous notes
    note selector: lambda function

articulation
    dur_abs(dur, pred)
    dur_rel(factor, pred)

grace notes in text notation
    1/32 - b 1/4 c
    parameterize the 1/32?
        dur(s): look up s and make that current dur
        note(p): look up p and play note w that pitch

------------
Measures

for metric emphases, need to know measure offsets
NoteSet has a member ns.measures: list of measure starts
NoteSet.add_measure(t)
NoteSet.add_measures(t, dt, n)
text notion: 'm' means measure start

Note.measure_offset: time from last measure boundary

metric emphasis:
    vol_adjust_func() with appropriate func
metric rubato (e.g. waltz rhythm)
    as base tempo:
        allow local tempo adjustments?
            slow down 2nd beat
        limited local adjustment
            specify integral function
            apply to limited set of notes, starting at given time
            normalize to that it ends at original time
            
    as adjustment:
        delay notes beyond 2nd beat
-------------
Sustain pedal

ns.sustain_pedal(t, dt, level)
ns.sostenuto_pedal(t, dt, level)
    apply pedal from t to d+dt at given level (0..1)
    This is stored in a separate NoteSet.pedal list
    write_midi adds the appropriate CC commands.

    In the timing logic, add pedal events to the start/end structure.
    Run the set-tempo logic.
    This gives the end perf times.
    start perf time is determined as follows:
    sustain pedal:
        start time is the min of the start times
        of notes with score times in the pedal interal;
        we need to "catch" all these notes, even if they got moved earlier
    sostenuto pedal:
        if a note is active (in score time) at the pedal start,
        but its perf time is greater than pedal perf start,
        set pedal perf to that time

Note: in Pianoteq, 0..63 is off.  64..127 is on a little to all the way

Note 2: CC 64 is sustain pedal;
CC is middle (sostenuto) pedal
    send this command after all notes of that start time

------------------
entering large scores

Goal: make it easy to enter and test scores in small pieces

2 approaches:

1) notation: "reset" means return to middle C, 1/4 dur
    this lets you define separate strings and concatenate them

2) Appending notes:
    c() returns a NoteSet object
        cur_time is the duration
        This leaves the door open for specifying measures and pedal in notation

    NoteSet.append([ns1, ns2,...])
        append NoteSets starting at cur_time
        set cur_time to end of longest
    NoteSet.insert(t, ns)
        insert NoteSet starting at t
        doesn't change cur_time
    NoteSet.insert_note(t, n)
    NoteSet.append_note(n)

-------------
Where to announce
    Reddit?
    hacker news (ycombinator.com)
    Facebook
    Pianoteq message boards
    Groupmuse message boards?
    Marc, Ron, Monica
    Gareth
    David Jaffe?
    Music 21 guy
-----------------
adjustments in score time

should it be possible to move notes in score time as well as perf time?
E.g. t_adjust_notes() and t_adjust_pred()
could have counterparts that change score time and/or duration.
and roll() too.

With the caution that if you insert score time,
you need to take that into account everywhere after that.

Need to change measure and pedal times in that case too

Note: we already have duration adjustment in score time.

-----------------
Kraft:

numula to revolutionize music

pianists don't have conductors

numula as better metronome

graphic expression of nuance

teacher creates "conductor score"

chamber music practice

===============
4/29/22

new approach to piecewise functions

vol is initially .5

vol_adjust_ptf(
    ns,
    selector,
    start_time,
    val_linear(pp, p, 30/8),
    ...
])

vol_adjust(
    ns, 
    selector,
    factor

vol_adjust_fn(
    ns.
    selector,
    fund

pp, ff etc. are in 0..2

tempo_adjust_ptf(
    ns,
    selector= True,
    start_time = 0,
    bpm = True,
    pedal = False,
    normalize = False
    [
        tempo_linear(24/8, [40,50]),
        tempo_linear(24/8, [50,30]),
    ]
)

val_linear and tempo_linear are classes

---------------
S = score time, P = perf time
for timing adjustment, the value of a PFT function at score time s
is dP/dS(s): the rate at which P increases with S.
Smaller value = faster

------------------
Numula editor GUI
X = time
Y = channels
top channel shows the score
    maybe piano roll
    show note tags
Each channel is a list of non-overlapping operators
operator
    tempo_adjust_pft, pause etc.
    select operators from list
    drag and drop to place
    drag to resize
    selector function: textual
PFT operators
    sequence of segments
    drag, drop, resize
    drag to change parameters (y0, y1)

Can copy and paste an operator or a segment
when paste, can "link" the copy
(changes to one change all)

Can drag start/end markers
space bar: play selected interval
-------------------
panning

- make a MIDI file with lots of notes
    of different pitches, same volume

- experiment with panning:
    mono: sum channels
    stereo: assume some angle between channels

- use PFTs for angle

making a spatialized multi-voice piece:
- tag notes with voice names
- ns.write_midi() takes selector; write voices to separate files
- pianoteq.midi_to_wav(mono) for each voice
- use write_pos_file() to write pos file for each voice
    (with its own PFT)
- make a zero signal
- for each voice, use pan_signal() to add panned voice
===========================
exponential PFT primitive:
===========================
repetition in notation

do it in notate, or using python stuff?


maintain a stack of (nleft, start)

maintain a "program counter" i

while i < len(input)
    token = input[i]
    if token is *n
        push (n, i)
    elif token is *
        t = top of stack
        if t.nleft == 0
            pop stack
        else
            t.nleft -= 1
            i = t.start
    else
        output token
------------
notate: support
    _4
    .4
    c5+ (or c+5?)
